package effio

import (
	"log"
	"os"
	"os/exec"
	"path"
)

// TODO:
// * check for root
// * proper handling of mkdir
func (cmd *Cmd) Mountall() {
	var idFlag, pathFlag string
	fs := cmd.FlagSet
	fs.StringVar(&pathFlag, "path", "suites/", "suite path, as generated by effio make")
	fs.StringVar(&idFlag, "id", "", "Id of the test suite")
	fs.Parse(cmd.Args)

	jsonPath := path.Join(pathFlag, idFlag, "suite.json")
	_, err := os.Stat(jsonPath)
	if err != nil {
		log.Fatalf("Could not stat file '%s': %s\n", jsonPath, err)
	}

	suite := LoadSuiteJson(jsonPath)

	// could use syscall.Mount but this is simpler for now
	// due to mount doing autodetection of filesystem
	mountPath, err := exec.LookPath("mount")
	if err != nil {
		log.Fatalf("Could not locate 'mount' in PATH: %s\n", err)
	}

	for _, test := range suite.Tests {
		if test.Device.Ignore {
			continue
		}

		err = os.Mkdir(test.Device.Mountpoint, 0755)
		if err != nil {
			log.Printf("mkdir failed: %s\n", err)
		}

		log.Printf("%s %s %s\n", mountPath, test.Device.Device, test.Device.Mountpoint)

		cmd := exec.Command(mountPath, test.Device.Device, test.Device.Mountpoint)

		if err := cmd.Start(); err != nil {
			log.Printf("\tcould not execute: %s\n", err)
		}

		// TODO: capture stderr

		err = cmd.Wait()

		// it might be OK to let 1 fio command out of a suite fail?
		if err != nil {
			log.Printf("\tmount failed: %s\n", err)
		}
	}
}
