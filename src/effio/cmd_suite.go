package effio

import (
	"log"
	"os"
	"path"
	"regexp"
)

// should never have a Run() attached since this is meant to be
// used only as a mixin with other suite-based commands
type SuiteCmd struct {
	Cmd
	Parsed    bool
	WorkPath  string
	SuitePath string
	JsonPath  string
	IdFlag    string
	PathFlag  string
	InclFlag  string
	ExclFlag  string
	Incl      *regexp.Regexp
	Excl      *regexp.Regexp
}

// create a SuiteCmd from an existing Cmd
func (cmd *Cmd) ToSuiteCmd() SuiteCmd {
	incl := regexp.MustCompile(".") // include everything by default
	excl := regexp.MustCompile("")  // exclude nothing by default
	sc := SuiteCmd{*cmd, false, "", "", "", "", "", "", "", incl, excl}
	return sc
}

// safe to call multiple times
func (sc *SuiteCmd) ParseArgs() {
	sc.FlagSet.StringVar(&sc.PathFlag, "path", "suites/", "suite path, as generated by effio make")
	sc.FlagSet.StringVar(&sc.IdFlag, "id", "", "Id of the test suite")
	sc.FlagSet.StringVar(&sc.InclFlag, "incl", "", "regex matching tests to include in graph")
	sc.FlagSet.StringVar(&sc.ExclFlag, "excl", "", "regex matching tests to exclude from graph")

	err := sc.FlagSet.Parse(sc.Args)
	if err != nil {
		log.Fatalf("Could not parse command-line arguments: %s\n", err)
	}

	// use full paths internally
	// TODO: this currently only supports relative paths and will break on rooted paths
	sc.WorkPath, err = os.Getwd()
	if err != nil {
		log.Fatalf("Could not get working directory: %s\n", err)
	}
	sc.SuitePath = path.Join(sc.WorkPath, sc.PathFlag)

	// Process -incl & -excl
	// -excl has higher priority than -incl so you can -incl and then
	// pare it down with -excl
	// -incl is a whitelist
	if len(sc.InclFlag) > 0 {
		sc.Incl, err = regexp.Compile(sc.InclFlag)
		if err != nil {
			log.Fatalf("-incl '%s': regex could not be compiled: %s\n", sc.InclFlag, err)
		}
	}

	// -excl is a blacklist and is applied after the whitelist in LoadSuite()
	if len(sc.ExclFlag) > 0 {
		sc.Excl, err = regexp.Compile(sc.ExclFlag)
		if err != nil {
			log.Fatalf("-excl '%s': regex could not be compiled: %s\n", sc.ExclFlag, err)
		}
	}
}

func (sc *SuiteCmd) LoadSuite() Suite {
	// load up the suite json
	sc.JsonPath = path.Join(sc.WorkPath, sc.PathFlag, sc.IdFlag, "suite.json")
	_, err := os.Stat(sc.JsonPath)
	if err != nil {
		log.Fatalf("Could not stat suite json file '%s': %s\n", sc.JsonPath, err)
	}
	suite := LoadSuiteJson(sc.JsonPath)

	// filter out unwanted tests from suite.Tests with -incl/-excl
	// could be more clever here but KISS
	var tests Tests
	for _, test := range suite.Tests {
		// when no -incl is specified, all tests are included by default
		keep := true
		if len(sc.InclFlag) > 0 {
			// but when one is specified, -incl becomes a whitelisting RE
			keep = false
			if sc.Incl.MatchString(test.Name) {
				keep = true
			}
		}

		// blacklist RE always works the same and always comes after -incl
		if len(sc.ExclFlag) > 0 && sc.Excl.MatchString(test.Name) {
			keep = false
		}

		// finally, make sure the test has actually run/succeeded
		// this allows for graphing partially executed / crashed suites
		if test.FioJsonSize(sc.SuitePath) == 0 {
			log.Printf("%s is missing or empty, skipping test '%s'", test.FioJson, test.Name)
			keep = false
		}

		if keep {
			tests = append(tests, test)
		}
	}

	// swap out the test list
	suite.Tests = tests

	return suite
}
